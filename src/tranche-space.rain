tokens:
  polygon-dai:
    network: polygon
    address: 0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063
    decimals: 18
    symbol: DAI
  polygon-wmatic:
    network: polygon
    address: 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270
    decimals: 18
    symbol: WMATIC

orders:
  polygon-tranche-space-buy-order:
    network: polygon
    orderbook: polygon
    deployer: polygon
    inputs:
        - token: polygon-wmatic
          decimals: 18
          vault-id: 0x11
    outputs:
        - token: polygon-dai
          decimals: 18
          vault-id: 0x11
          
  polygon-tranche-space-sell-order:
    network: polygon
    orderbook: polygon
    deployer: polygon
    inputs:
        - token: polygon-dai
          decimals: 18
          vault-id: 0x11
    outputs:
        - token: polygon-wmatic
          decimals: 18
          vault-id: 0x11
        
scenarios:
    polygon-experimental-tranche-space-linear-sell:
        network: polygon
        deployer: polygon
        orderbook: polygon
        runs: 1000
        bindings:
          tranche-space-per-second: 0
          tranche-space-recharge-delay: 0
          tranche-size-expr: '''constant-growth'
          tranche-size-base: 5000e18
          tranche-size-growth: 1e18
          io-ratio-expr: '''linear-growth'
          io-ratio-base: 6e18
          io-ratio-growth: 1e17
          reference-stable: 0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063
          reference-stable-decimals: 18
          reference-reserve: 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270
          reference-reserve-decimals: 18
          min-tranche-space-diff: 1e17
          tranche-space-snap-threshold: 1e16 
          amount-is-output: 0
          get-last-tranche: '''get-test-last-tranche'
          set-last-tranche: '''set-test-last-tranche'
          io-ratio-multiplier: '''io-ratio-multiplier-identity'
          test-last-update-time: 1710764220
          test-now: 1710764221
          
                  
charts:
    tranche-space-linear:
        scenario: polygon-experimental-tranche-space-linear-sell
        plots:
            tranche-space vs ratio:
                data:
                    x: 0.0
                    y: 0.7
                plot-type: dot
            tranche-space vs amount:
                data:
                    x: 0.0
                    y: 0.6
                plot-type: dot
---
#tranche-space-per-second !The amount of tranche space that is recharged per second as a normalized 18 decimal fixed point value.
#tranche-space-recharge-delay !The duration in seconds that no recharging occurs after a trade occurs.

#tranche-size-expr !The binding to get the tranche size for the current tranche space.
#tranche-size-base !Base tranche size is the size of the smallest tranche, denominated in output token.
#tranche-size-growth !The exponential growth factor of the size of each tranche, as a decimal 18 fixed point number. E.g. 1e16 is 1% output amount growth per tranche.

#io-ratio-expr !The binding to get the IO ratio for the current tranche space.
#io-ratio-base !The base IO ratio, as a decimal 18 fixed point number. This is the IO ratio at tranche space 0 and grows according to the growth factor per tranche.
#io-ratio-growth !The exponential growth factor of the IO ratio, as a decimal 18 fixed point number. E.g. 1e16 is 1% io-ratio growth per tranche.

#reference-stable !The stable token that is used as a reference for the TWAP to offer dollar equivalent conversions.
#reference-stable-decimals !The number of decimals of the reference stable token.
#reference-reserve !The token that will be used to compare against the reference stable token to calculate the TWAP for dollar equivalent conversions.
#reference-reserve-decimals !The number of decimals of the reserve token.
#twap-duration !The duration in seconds of the TWAP window for dollar equivalence conversions.
#twap-fee !The uniswap fee tier to use for the TWAP.

#min-tranche-space-diff !The minimum tranche space difference that is allowed per trade, as a decimal 18 fixed point number. Prevents dusting the strat to stop it recharging.
#tranche-space-snap-threshold !The threshold in tranche space to snap to the nearest tranche to avoid dust issues at the edges.

#get-last-tranche !The binding to get the last tranche space and update time.
#set-last-tranche !The binding to set the last tranche space and update time.

#test-tranche-space-before !Returned by get-test-last-tranche to allow the tranche space before to be bound for testing.
#test-last-update-time !Returned by get-test-last-tranche to allow the last update time to be bound for testing.
#test-now !Returned by get-test-last-tranche to allow the current time to be bound for testing.

#io-ratio-multiplier !The binding to get the IO ratio multiplier.

#amount-is-output !Whether the amount is an output or input amount. Non-zero means output (i.e. normal orderbook behaviour), zero means input.

#tranche-space-key "tranche-space"
#update-time-key "update-time"

#get-real-last-tranche
  tranche-space-before: get(hash(order-hash() tranche-space-key)),
  last-update-time: get(hash(order-hash() update-time-key)),
  now: block-timestamp();

#set-real-last-tranche
  tranche-space now:,
  :set(hash(order-hash() tranche-space-key) tranche-space),
  :set(hash(order-hash() update-time-key) now);

/* Forward the bindings through as is to the caller. */
#get-test-last-tranche
  _ _ _: int-mul(1e18 int-mod(test-tranche-space-before 1000)) test-last-update-time test-now;

/* There's nothing to set if we're just rebinding in tests. */
#set-test-last-tranche
  tranche-space now:;

#exponential-growth
  base rate t:,
  _: decimal18-exponential-growth(base rate t);

#linear-growth
  base rate t:,
  _: decimal18-linear-growth(base rate t);

#constant-growth
  base _ _:,
  _: base;

/**
 * To calculate a tranche without looping constructs, we have the idea of a 1D
 * tranche space that has a lower bound at 0 and we move through it linearly
 * as trades are made. Every decimal 18 unit of tranche space is a tranche.
 * The amount and price is derived from where we are in tranche space, and the
 * amount that we move through tranche space per trade is derived from real vault
 * movements.
 * Tranches are recharged at a constant rate in tranche space, which maps to a
 * non linear rate in token space, according to the derived relationship.
 */
#calculate-tranche
  tranche-space-before
  last-update-time
  now: call<get-last-tranche>(),
  recharge-duration: int-saturating-sub(now int-add(last-update-time tranche-space-recharge-delay)),
  recharged-tranche-space: decimal18-mul(int-to-decimal18(recharge-duration) tranche-space-per-second),
  /* repeat now for easy access by callers */
  _: now,
  tranche-space-now: decimal18-saturating-sub(tranche-space-before recharged-tranche-space),
  tranche-space-available: decimal18-headroom(tranche-space-now),
  tranche-total-size: call<'tranche-size-expr>(tranche-size-base tranche-size-growth decimal18-floor(tranche-space-now));

#io-ratio-multiplier-sell
  multiplier: uniswap-v3-twap-output-ratio(reference-stable reference-stable-decimals reference-reserve reference-reserve-decimals twap-duration 0 twap-fee);

#io-ratio-multiplier-buy
  multiplier: uniswap-v3-twap-output-ratio(reference-reserve reference-reserve-decimals reference-stable reference-stable-decimals twap-duration 0 twap-fee);

#io-ratio-multiplier-identity
  multiplier: 1e18;

#calculate-io
  tranche-space-now
  tranche-space-available
  tranche-total-size: call<'calculate-tranche>(),
  tranche-io-ratio: call<'io-ratio-expr>(io-ratio-base io-ratio-growth decimal18-floor(tranche-space-now)),
  final-io-ratio: decimal18-mul(tranche-io-ratio call<io-ratio-multiplier>()),
  amount-available: decimal18-mul(tranche-total-size tranche-space-available),
  amount: if(amount-is-output amount-available decimal18-div(amount-available final-io-ratio)),
  io-ratio: final-io-ratio;

#handle-io
  now
  tranche-space-before
  _
  tranche-total-size: call<'calculate-tranche>(),
  tranche-amount-diff: if(
    amount-is-output
    decimal18-scale-18-dynamic(context<4 1>() context<4 4>())
    decimal18-scale-18-dynamic(context<3 1>() context<3 4>())),
  tranche-space-diff: decimal18-div(tranche-amount-diff tranche-total-size),
  tranche-space-after: decimal18-add(tranche-space-before tranche-space-diff),
  /* Snap tranche space to the nearest tranche to avoid dust issues at the edges */
  tranche-space-after-snapped: decimal18-snap-to-unit(tranche-space-snap-threshold tranche-space-after),
  :ensure(
    greater-than-or-equal-to(tranche-space-after-snapped decimal18-add(tranche-space-before min-tranche-space-diff))
    "Minimum trade size not met."
  ),
  :call<set-last-tranche>(tranche-space-after-snapped now);